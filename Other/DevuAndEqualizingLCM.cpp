#include <bits/stdc++.h>
#define pb push_back
#define mp make_pair
#define fst first
#define snd second
#define fore(i,a,b) for(int i=a,ThxDem=b;i<ThxDem;++i)
using namespace std;
typedef long long ll;

ll gcd(ll a, ll b){return a?gcd(b%a,a):b;}
ll mulmod(ll a, ll b, ll m) {
	if(!b)return 0;
	ll q=mulmod(a,b/2,m);q=(q+q)%m;
	return b&1?(q+a)%m:q;
}
ll expmod(ll b, ll e, ll m){
	if(!e)return 1;
	ll q=expmod(b,e/2,m);q=mulmod(q,q,m);
	return e&1?mulmod(b,q,m):q;
}
bool is_prime_prob(ll n, int a){
	if(n==a)return true;
	ll s=0,d=n-1;
	while(d%2==0)s++,d/=2;
	ll x=expmod(a,d,n);
	if((x==1)||(x+1==n))return true;
	fore(_,0,s-1){
		x=mulmod(x,x,n);
		if(x==1)return false;
		if(x+1==n)return true;
	}
	return false;
}
bool rabin(ll n){ // true iff n is prime
	if(n==1)return false;
	int ar[]={2,3,5,7,11,13,17,19,23};
	fore(i,0,9)if(!is_prime_prob(n,ar[i]))return false;
	return true;
}
ll rho(ll n){
    if(!(n&1))return 2;
    ll x=2,y=2,d=1;
    ll c=rand()%n+1;
    while(d==1){
        x=(mulmod(x,x,n)+c)%n;
        y=(mulmod(y,y,n)+c)%n;
        y=(mulmod(y,y,n)+c)%n;
        if(x>=y)d=gcd(x-y,n);
        else d=gcd(y-x,n);
    }
    return d==n?rho(n):d;
}
void fact(ll n, map<ll,int>& f){ //O (lg n)^3
	if(n==1)return;
	if(rabin(n)){f[n]++;return;}
	ll q=rho(n);
	fact(q,f);fact(n/q,f);
}

class DevuAndEqualizingLCM {
public:
	int minimumOperationsNeeded(vector <long long> A, vector <long long> B) {
		map<ll,int> facta;
		map<ll,int> factb;
		map<ll,int> m;
		for(auto aa:A){
			m.clear();
			fact(aa,m);
			for(auto f : m){
				facta[f.fst] = max(f.snd, facta[f.fst]);
			}
		}
		m.clear();
		for(auto bb:B){
			m.clear();
			fact(bb,m);
			for(auto f : m){
				factb[f.fst] = max(f.snd, factb[f.fst]);
			}
		}
		int maya = 0;
		for(auto ma:facta){
			if(ma.snd>factb[ma.fst])maya=1;
		}
		int mena = 0;
		m.clear();
		for(auto bb:B){
			m.clear();
			fact(bb,m);
			int sumar = 0;
			for(auto f : m){
				if(f.snd>facta[f.fst])sumar=1;
			}
			if(sumar)mena++;
		}
		return max(mena,maya);
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, vector <long long> p0, vector <long long> p1, bool hasAnswer, int p2) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p0[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}";
	cout << "]" << endl;
	DevuAndEqualizingLCM *obj;
	int answer;
	obj = new DevuAndEqualizingLCM();
	clock_t startTime = clock();
	answer = obj->minimumOperationsNeeded(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <long long> p0;
	vector <long long> p1;
	int p2;
	
	{
	// ----- test 0 -----
	long long t0[] = {2ll,3ll};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	long long t1[] = {6ll};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 0;
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	long long t0[] = {2ll,6ll};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	long long t1[] = {4ll,6ll};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 1;
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	long long t0[] = {4ll,6ll,10ll};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	long long t1[] = {7ll,7ll,60ll,20ll};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 2;
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	long long t0[] = {5ll,4ll,6ll};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	long long t1[] = {7ll,9ll,13ll};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 3;
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	long long t0[] = {41ll,100ll,28ll,55ll,67ll,34ll,20ll,83ll,45ll,8ll,27ll,95ll,1ll,43ll,7ll,88ll,60ll,71ll,16ll,31ll,89ll,75ll,75ll,3ll,60ll,56ll,76ll,38ll,5ll};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	long long t1[] = {91ll,15ll,55ll,42ll,46ll,81ll,45ll,27ll,66ll,26ll,83ll,48ll,90ll,100ll,34ll,32ll,31ll,27ll};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 5;
	all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 5 -----
	long long t0[] = {97540245831ll,137068896362ll,514711863869ll,493787121165ll,834951815745ll,37979891065ll,568618248989ll,845422774812ll,388880393645ll,985781954575ll,604319452958ll,746201820162ll,231152838059ll,216843527666ll,273129662502ll,182176563686ll,147497146658ll,786575259172ll,809922390313ll,228908269659ll,973967867901ll,579874670191ll,125850829414ll,276107572013ll,258976667806ll,661763361945ll,677932923662ll,717999289076ll,640442431523ll,656032966532ll,590457054595ll,416409509380ll,29284130688ll,168848104208ll,5323300392ll,526319657599ll,790307412123ll,670316357228ll,14451351458ll,44944304007ll,184763758275ll};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	long long t1[] = {664062862940ll,371209195826ll,500760395677ll,213502574561ll,407987202195ll,618243198887ll,7507868706ll,982685603451ll,984624263743ll,184825285122ll,691193433687ll,794873502004ll,202552646911ll,831121828034ll,117809838201ll,837979301727ll,944009960595ll,875730091573ll,928487129172ll,564008033283ll,19444951901ll,148407051399ll,902802383260ll,727695291915ll,401932019635ll,875612048370ll,897127364705ll,602249064193ll,352855723818ll,640428054195ll,306092761693ll,743561916409ll,553098062995ll,711231338004ll,6626020059ll,954541653724ll,144164213750ll,882628116862ll,144064233877ll,487423289003ll,627548663637ll,43271989230ll,345201595127ll,141248813704ll,135109517871ll};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 45;
	all_right = KawigiEdit_RunTest(5, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!
